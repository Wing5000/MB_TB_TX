<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moonbeam Contract Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #60a5fa;
            margin-bottom: 10px;
            font-size: 2.2rem;
        }

        .contract-address {
            font-family: 'Courier New', monospace;
            color: #94a3b8;
            font-size: 0.9rem;
            background: #1e293b;
            padding: 8px 16px;
            border-radius: 8px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
            gap: 30px;
            flex-wrap: wrap;
        }

        .auto-refresh {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
            background: #374151;
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle.active {
            background: #10b981;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle.active .toggle-slider {
            transform: translateX(24px);
        }

        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #94a3b8;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #374151;
            border-top: 2px solid #60a5fa;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: #1e293b;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #334155;
            text-align: center;
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #60a5fa;
            margin-bottom: 5px;
        }

        .metric-label {
            color: #94a3b8;
            font-size: 0.9rem;
        }

        .table-container {
            background: #1e293b;
            border-radius: 12px;
            border: 1px solid #334155;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 15px 20px;
            text-align: left;
            border-bottom: 1px solid #334155;
        }

        th {
            background: #0f172a;
            color: #60a5fa;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background 0.2s;
        }

        th:hover {
            background: #1e293b;
        }

        .sort-indicator {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: #94a3b8;
            font-size: 0.8rem;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tbody tr {
            transition: background 0.2s;
        }

        tbody tr:hover {
            background: #0f172a;
        }

        .rank {
            color: #fbbf24;
            font-weight: bold;
            text-align: center;
            width: 80px;
        }

        .address {
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #94a3b8;
            max-width: 300px;
            word-break: break-all;
        }

        .tx-count {
            font-weight: bold;
            color: #10b981;
            text-align: right;
            width: 120px;
        }

        .error-message {
            background: #7f1d1d;
            color: #fca5a5;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #dc2626;
            text-align: center;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #94a3b8;
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
        }

        .pagination button {
            background: #374151;
            border: none;
            color: #e2e8f0;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 100px;
        }

        .pagination button:hover:not(:disabled) {
            background: #4b5563;
            transform: translateY(-1px);
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .page-info {
            color: #94a3b8;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            body {
                padding: 15px;
            }

            .header h1 {
                font-size: 1.8rem;
            }

            .controls {
                flex-direction: column;
                gap: 20px;
            }

            .metrics {
                grid-template-columns: 1fr;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: 12px 10px;
            }

            .address {
                font-size: 0.75rem;
                max-width: 200px;
            }

            .pagination {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Moonbeam Contract Monitor</h1>
            <div class="contract-address">0x86c66061a0e55d91c8bfa464fe84dc58f8733253</div>
            <div style="background: #1e293b; padding: 10px; border-radius: 8px; margin-top: 10px; font-size: 0.85rem; color: #94a3b8; text-align: left;">
                <strong style="color: #10b981;">‚úÖ LIVE MODE:</strong> U≈ºywa prawdziwych danych z Moonbeam RPC<br>
                üîó Endpoints: rpc.api.moonbeam.network, ankr.com, 1rpc.io i inne<br>
                üìä Pobiera wszystkie transakcje do kontraktu za pomocƒÖ eth_getLogs
            </div>
        </div>

        <div class="controls">
            <div class="auto-refresh">
                <span>Auto-refresh (60s):</span>
                <div class="toggle active" id="autoRefreshToggle">
                    <div class="toggle-slider"></div>
                </div>
            </div>
            <div class="status">
                <span id="statusText">Inicjalizacja...</span>
                <div id="loadingSpinner" class="spinner"></div>
            </div>
        </div>

        <div class="metrics">
            <div class="metric-card">
                <div class="metric-value" id="uniqueAddresses">-</div>
                <div class="metric-label">Unikalne adresy</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="totalTransactions">-</div>
                <div class="metric-label">≈ÅƒÖcznie transakcji</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="lastUpdate">-</div>
                <div class="metric-label">Ostatnia aktualizacja</div>
            </div>
        </div>

        <div id="errorContainer"></div>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th class="rank" id="rankHeader">
                            #
                            <span class="sort-indicator">‚Üì</span>
                        </th>
                        <th class="address" id="addressHeader">
                            Adres
                            <span class="sort-indicator"></span>
                        </th>
                        <th class="tx-count" id="txCountHeader">
                            Transakcje
                            <span class="sort-indicator"></span>
                        </th>
                    </tr>
                </thead>
                <tbody id="transactionTableBody">
                    <tr>
                        <td colspan="3" class="empty-state">≈Åadowanie danych...</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="pagination">
            <button id="prevPage">‚Äπ Poprzednia</button>
            <span class="page-info" id="pageInfo">Strona 1</span>
            <button id="nextPage">Nastƒôpna ‚Ä∫</button>
        </div>
    </div>

    <script>
        class MoonbeamContractMonitor {
            constructor() {
                this.contractAddress = '0x86c66061a0e55d91c8bfa464fe84dc58f8733253';
                this.rpcEndpoints = [
                    'https://rpc.api.moonbeam.network',
                    'https://moonbeam.blastapi.io/b8a802c6-651e-4cf0-a151-6ecbd1a18b9d',
                    'https://moonbeam.unitedbloc.com:2000',
                    'https://rpc.ankr.com/moonbeam',
                    'https://1rpc.io/glmr'
                ];
                this.currentRpcIndex = 0;

                // Moonscan API configuration (set via localStorage: moonscanApiKey)
                this.moonscanApiKey = localStorage.getItem('moonscanApiKey') || '';
                this.moonscanRateLimit = 5; // requests per second
                this.moonscanLastRequest = 0;
                
                this.transactionData = new Map();
                this.displayData = [];
                this.currentPage = 1;
                this.itemsPerPage = 25;
                this.sortColumn = 'txCount';
                this.sortDirection = 'desc';
                this.autoRefreshEnabled = true;
                this.refreshInterval = null;
                this.isLoading = false;
                this.refreshCount = 0;
                
                this.initializeElements();
                this.setupEventListeners();
                this.startInitialLoad();
            }

            initializeElements() {
                this.elements = {
                    autoRefreshToggle: document.getElementById('autoRefreshToggle'),
                    statusText: document.getElementById('statusText'),
                    loadingSpinner: document.getElementById('loadingSpinner'),
                    uniqueAddresses: document.getElementById('uniqueAddresses'),
                    totalTransactions: document.getElementById('totalTransactions'),
                    lastUpdate: document.getElementById('lastUpdate'),
                    errorContainer: document.getElementById('errorContainer'),
                    prevPage: document.getElementById('prevPage'),
                    nextPage: document.getElementById('nextPage'),
                    pageInfo: document.getElementById('pageInfo'),
                    tableBody: document.getElementById('transactionTableBody'),
                    rankHeader: document.getElementById('rankHeader'),
                    addressHeader: document.getElementById('addressHeader'),
                    txCountHeader: document.getElementById('txCountHeader')
                };
            }

            setupEventListeners() {
                this.elements.autoRefreshToggle.addEventListener('click', () => {
                    this.toggleAutoRefresh();
                });

                this.elements.prevPage.addEventListener('click', () => {
                    if (this.currentPage > 1) {
                        this.currentPage--;
                        this.displayTable();
                    }
                });

                this.elements.nextPage.addEventListener('click', () => {
                    const maxPages = Math.ceil(this.displayData.length / this.itemsPerPage);
                    if (this.currentPage < maxPages) {
                        this.currentPage++;
                        this.displayTable();
                    }
                });

                // Sortowanie kolumn
                this.elements.rankHeader.addEventListener('click', () => this.sortBy('rank'));
                this.elements.addressHeader.addEventListener('click', () => this.sortBy('address'));
                this.elements.txCountHeader.addEventListener('click', () => this.sortBy('txCount'));
            }

            toggleAutoRefresh() {
                this.autoRefreshEnabled = !this.autoRefreshEnabled;
                this.elements.autoRefreshToggle.classList.toggle('active', this.autoRefreshEnabled);
                
                if (this.autoRefreshEnabled) {
                    this.startAutoRefresh();
                } else {
                    this.stopAutoRefresh();
                }
            }

            startAutoRefresh() {
                this.stopAutoRefresh();
                this.refreshInterval = setInterval(() => {
                    if (!this.isLoading) {
                        this.refreshCount++;
                        console.log(`Auto-refresh #${this.refreshCount}`);
                        this.loadTransactionData();
                    }
                }, 60000);
            }

            stopAutoRefresh() {
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                    this.refreshInterval = null;
                }
            }

            async startInitialLoad() {
                await this.loadTransactionData();
                if (this.autoRefreshEnabled) {
                    this.startAutoRefresh();
                }
            }

            showError(message) {
                this.elements.errorContainer.innerHTML = `
                    <div class="error-message">
                        <strong>B≈ÇƒÖd:</strong> ${message}
                    </div>
                `;
            }

            hideError() {
                this.elements.errorContainer.innerHTML = '';
            }

            setLoading(loading) {
                this.isLoading = loading;
                this.elements.loadingSpinner.style.display = loading ? 'block' : 'none';
                
                if (loading) {
                    this.elements.statusText.textContent = 'Pobieranie danych...';
                } else {
                    const count = this.transactionData.size;
                    const total = Array.from(this.transactionData.values()).reduce((sum, count) => sum + count, 0);
                    this.elements.statusText.textContent = `${count} adres√≥w, ${total} transakcji`;
                }
            }

            async loadTransactionData() {
                this.setLoading(true);
                this.hideError();

                try {
                    const allTransactions = await this.fetchAllTransactions();
                    this.processTransactions(allTransactions);
                    this.prepareDisplayData();
                    this.displayTable();
                    this.updateMetrics();
                    
                    console.log(`Za≈Çadowano ${allTransactions.length} transakcji z ${this.transactionData.size} unikalnych adres√≥w`);
                } catch (error) {
                    console.error('Error loading transaction data:', error);
                    
                    let errorMessage = 'Nieznany b≈ÇƒÖd';
                    if (error.message.includes('Failed to fetch')) {
                        errorMessage = 'Problem z po≈ÇƒÖczeniem internetowym. Sprawd≈∫ po≈ÇƒÖczenie i spr√≥buj ponownie.';
                    } else if (error.message.includes('Wszystkie RPC endpoints')) {
                        errorMessage = 'Wszystkie RPC endpoints Moonbeam sƒÖ niedostƒôpne. Spr√≥buj ponownie za chwilƒô.';
                    } else {
                        errorMessage = error.message;
                    }
                    
                    this.showError(errorMessage);
                } finally {
                    this.setLoading(false);
                }
            }

            async fetchTransactionsWithMoonscan() {
                const baseUrl = 'https://api-moonbeam.moonscan.io/api';
                const params = new URLSearchParams({
                    module: 'account',
                    action: 'txlist',
                    address: this.contractAddress,
                    startblock: '0',
                    endblock: '99999999',
                    sort: 'asc'
                });

                if (this.moonscanApiKey) {
                    params.append('apikey', this.moonscanApiKey);
                }

                const maxRetries = 5;

                for (let attempt = 0; attempt < maxRetries; attempt++) {
                    try {
                        const now = Date.now();
                        const delay = Math.max(0, (1000 / this.moonscanRateLimit) - (now - this.moonscanLastRequest));
                        if (delay > 0) {
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                        this.moonscanLastRequest = Date.now();

                        const response = await fetch(`${baseUrl}?${params.toString()}`);
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }

                        const data = await response.json();

                        if (data.status !== '1') {
                            const message = (data.message || data.result || 'Unknown Moonscan error');
                            if (message.toLowerCase().includes('max rate limit')) {
                                const backoff = (attempt + 1) * 1000;
                                console.warn(`‚ö†Ô∏è Moonscan rate limit reached, retrying in ${backoff}ms`);
                                await new Promise(resolve => setTimeout(resolve, backoff));
                                continue;
                            }
                            throw new Error(message);
                        }

                        const txs = data.result
                            .filter(tx => tx.to && tx.to.toLowerCase() === this.contractAddress.toLowerCase())
                            .map(tx => ({
                                from: tx.from,
                                to: tx.to,
                                hash: tx.hash,
                                blockNumber: parseInt(tx.blockNumber)
                            }));

                        console.log(`üîç Pobieranie transakcji z Moonscan API: ${txs.length}`);
                        return txs;
                    } catch (error) {
                        console.error('Moonscan API error:', error.message);
                        if (attempt === maxRetries - 1) {
                            throw error;
                        }
                    }
                }

                return [];
            }

            async fetchTransactionsWithRPC() {
                const transactions = [];
                let fromBlock = 0;
                const toBlock = 'latest';
                // Rozmiar batch jest dynamiczny, zmniejszany przy b≈Çƒôdach aby odciƒÖ≈ºyƒá RPC
                let batchSize = 5000; // Reasonable batch size
                let currentFromBlock = fromBlock;
                
                console.log('üîç Pobieranie transakcji z Moonbeam RPC...');
                
                // Get current block number first
                const latestBlockHex = await this.makeRpcCall('eth_blockNumber', []);
                const latestBlock = parseInt(latestBlockHex, 16);
                console.log(`üìä Najnowszy blok: ${latestBlock}`);

                while (currentFromBlock < latestBlock) {
                    const batchToBlock = Math.min(currentFromBlock + batchSize - 1, latestBlock);
                    
                    console.log(`üì¶ Pobieranie blok√≥w ${currentFromBlock} - ${batchToBlock}`);
                    
                    try {
                        const logs = await this.makeRpcCall('eth_getLogs', [{
                            fromBlock: `0x${currentFromBlock.toString(16)}`,
                            toBlock: `0x${batchToBlock.toString(16)}`,
                            address: this.contractAddress
                        }]);

                        if (logs && logs.length > 0) {
                            // Dla ka≈ºdego loga, pobierz szczeg√≥≈Çy transakcji
                            const batchTxs = await this.getTransactionDetails(logs);
                            transactions.push(...batchTxs);
                            console.log(`‚úÖ Znaleziono ${logs.length} log√≥w, ${batchTxs.length} unikalnych transakcji`);
                        } else {
                            console.log(`‚è≠Ô∏è  Brak transakcji w blokach ${currentFromBlock} - ${batchToBlock}`);
                        }

                    } catch (error) {
                        console.error(`‚ùå B≈ÇƒÖd dla blok√≥w ${currentFromBlock} - ${batchToBlock}:`, error.message);
                        // Try smaller batch on error and ensure it never goes below 1000
                        if (error.message.includes('query returned more than')) {
                            console.log('üìâ Zmniejszam rozmiar batch...');
                            batchSize = Math.max(1000, Math.floor(batchSize / 2)); // dziel rozmiar przez 2, min. 1000
                            continue;
                        }
                    }

                    currentFromBlock = batchToBlock + 1;
                    
                    // Add delay to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Safety break for very large chains
                    if (currentFromBlock > fromBlock + 50000) {
                        console.log('üõë OsiƒÖgniƒôto limit bezpiecze≈Ñstwa (50k blok√≥w)');
                        break;
                    }
                }

                console.log(`üéâ Pobieranie zako≈Ñczone: ${transactions.length} unikalnych transakcji`);
                return transactions;
            }

            async getTransactionDetails(logs) {
                const uniqueTxHashes = [...new Set(logs.map(log => log.transactionHash))];

                // Prosty limiter wsp√≥≈Çbie≈ºno≈õci (podobny do p-limit)
                const createLimiter = (concurrency) => {
                    const queue = [];
                    let activeCount = 0;

                    const next = () => {
                        activeCount--;
                        if (queue.length > 0) {
                            const fn = queue.shift();
                            fn();
                        }
                    };

                    return (fn) => new Promise((resolve, reject) => {
                        const run = () => {
                            activeCount++;
                            Promise.resolve(fn()).then(resolve).catch(reject).finally(next);
                        };

                        if (activeCount < concurrency) {
                            run();
                        } else {
                            queue.push(run);
                        }
                    });
                };

                const limit = createLimiter(5); // limit r√≥wnoleg≈Çych zapyta≈Ñ

                const txPromises = uniqueTxHashes.map((txHash) =>
                    limit(async () => {
                        try {
                            return await this.makeRpcCall('eth_getTransactionByHash', [txHash]);
                        } catch (error) {
                            console.error(`B≈ÇƒÖd pobierania transakcji ${txHash}:`, error.message);
                            return null;
                        }
                    })
                );

                const settled = await Promise.allSettled(txPromises);

                return settled
                    .filter(res => res.status === 'fulfilled' && res.value && res.value.to && res.value.to.toLowerCase() === this.contractAddress.toLowerCase())
                    .map(res => ({
                        from: res.value.from,
                        to: res.value.to,
                        hash: res.value.hash,
                        blockNumber: parseInt(res.value.blockNumber, 16)
                    }));
            }

            async makeRpcCall(method, params) {
                let lastError = null;

                // Try each RPC endpoint
                for (let i = 0; i < this.rpcEndpoints.length; i++) {
                    const rpcIndex = (this.currentRpcIndex + i) % this.rpcEndpoints.length;
                    const rpcUrl = this.rpcEndpoints[rpcIndex];

                    try {
                        console.log(`üîó Pr√≥bujƒô RPC ${rpcIndex + 1}/${this.rpcEndpoints.length}: ${rpcUrl.substring(0, 40)}...`);
                        
                        const response = await fetch(rpcUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                jsonrpc: '2.0',
                                id: Date.now(),
                                method: method,
                                params: params
                            })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const data = await response.json();

                        if (data.error) {
                            throw new Error(`RPC Error: ${data.error.message || data.error.code}`);
                        }

                        if (!data.result && data.result !== 0 && data.result !== '0x0') {
                            throw new Error('Brak wyniku w odpowiedzi RPC');
                        }

                        // Success - remember this endpoint works
                        this.currentRpcIndex = rpcIndex;
                        return data.result;

                    } catch (error) {
                        console.log(`‚ùå RPC ${rpcIndex + 1} nie dzia≈Ça: ${error.message}`);
                        lastError = error;
                        
                        // Add delay before trying next endpoint
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }

                // All endpoints failed
                throw new Error(`Wszystkie RPC endpoints nie dzia≈ÇajƒÖ. Ostatni b≈ÇƒÖd: ${lastError?.message}`);
            }

            async fetchAllTransactions() {
                try {
                    const moonscanTxs = await this.fetchTransactionsWithMoonscan();
                    if (moonscanTxs && moonscanTxs.length > 0) {
                        return moonscanTxs;
                    }
                    console.log('‚ÑπÔ∏è Brak danych z Moonscanu, prze≈ÇƒÖczam na RPC');
                } catch (error) {
                    console.warn('‚ö†Ô∏è B≈ÇƒÖd Moonscan, prze≈ÇƒÖczam na RPC:', error.message);
                }

                return await this.fetchTransactionsWithRPC();
            }

            processTransactions(transactions) {
                this.transactionData.clear();

                transactions.forEach(tx => {
                    // Wszystkie transakcje z RPC sƒÖ ju≈º przefiltrowane (tylko do naszego kontraktu)
                    const fromAddress = tx.from.toLowerCase();
                    const current = this.transactionData.get(fromAddress) || 0;
                    this.transactionData.set(fromAddress, current + 1);
                });
            }

            prepareDisplayData() {
                this.displayData = Array.from(this.transactionData.entries())
                    .map(([address, txCount]) => ({
                        address,
                        txCount,
                        rank: 0
                    }));

                this.sortData();
            }

            sortBy(column) {
                if (this.sortColumn === column) {
                    this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    this.sortColumn = column;
                    this.sortDirection = column === 'txCount' ? 'desc' : 'asc';
                }

                this.updateSortIndicators();
                this.sortData();
                this.displayTable();
            }

            updateSortIndicators() {
                document.querySelectorAll('.sort-indicator').forEach(indicator => {
                    indicator.textContent = '';
                });

                let activeHeader;
                switch (this.sortColumn) {
                    case 'rank':
                        activeHeader = this.elements.rankHeader;
                        break;
                    case 'address':
                        activeHeader = this.elements.addressHeader;
                        break;
                    case 'txCount':
                        activeHeader = this.elements.txCountHeader;
                        break;
                }

                if (activeHeader) {
                    const indicator = activeHeader.querySelector('.sort-indicator');
                    indicator.textContent = this.sortDirection === 'asc' ? '‚Üë' : '‚Üì';
                }
            }

            sortData() {
                this.displayData.sort((a, b) => {
                    let comparison = 0;
                    
                    switch (this.sortColumn) {
                        case 'rank':
                            comparison = a.rank - b.rank;
                            break;
                        case 'address':
                            comparison = a.address.localeCompare(b.address);
                            break;
                        case 'txCount':
                            comparison = a.txCount - b.txCount;
                            break;
                    }

                    return this.sortDirection === 'asc' ? comparison : -comparison;
                });

                // Aktualizuj rangi po sortowaniu
                this.displayData.forEach((item, index) => {
                    item.rank = index + 1;
                });
            }

            displayTable() {
                const start = (this.currentPage - 1) * this.itemsPerPage;
                const end = start + this.itemsPerPage;
                const pageData = this.displayData.slice(start, end);

                if (pageData.length === 0) {
                    this.elements.tableBody.innerHTML = `
                        <tr>
                            <td colspan="3" class="empty-state">Brak transakcji do wy≈õwietlenia</td>
                        </tr>
                    `;
                } else {
                    this.elements.tableBody.innerHTML = pageData.map(item => `
                        <tr>
                            <td class="rank">${item.rank}</td>
                            <td class="address">${item.address}</td>
                            <td class="tx-count">${item.txCount.toLocaleString()}</td>
                        </tr>
                    `).join('');
                }

                this.updatePagination();
            }

            updatePagination() {
                const maxPages = Math.ceil(this.displayData.length / this.itemsPerPage);
                this.elements.pageInfo.textContent = maxPages > 0 ? `Strona ${this.currentPage} z ${maxPages}` : 'Strona 0 z 0';
                this.elements.prevPage.disabled = this.currentPage === 1 || maxPages === 0;
                this.elements.nextPage.disabled = this.currentPage >= maxPages || maxPages === 0;
            }

            updateMetrics() {
                const uniqueCount = this.transactionData.size;
                const totalTx = Array.from(this.transactionData.values()).reduce((sum, count) => sum + count, 0);
                const now = new Date().toISOString().replace('T', ' ').substring(0, 19);

                this.elements.uniqueAddresses.textContent = uniqueCount.toLocaleString();
                this.elements.totalTransactions.textContent = totalTx.toLocaleString();
                this.elements.lastUpdate.textContent = now;
            }
        }

        // Uruchom monitor po za≈Çadowaniu strony
        document.addEventListener('DOMContentLoaded', () => {
            new MoonbeamContractMonitor();
        });
    </script>
</body>
</html>